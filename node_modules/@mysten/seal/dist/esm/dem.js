import { bcs } from "@mysten/bcs";
import { equalBytes } from "@noble/curves/abstract/utils";
import { hmac } from "@noble/hashes/hmac";
import { sha3_256 } from "@noble/hashes/sha3";
import { InvalidCiphertextError } from "./error.js";
import { xorUnchecked } from "./utils.js";
const iv = Uint8Array.from([
  138,
  55,
  153,
  253,
  198,
  46,
  121,
  219,
  160,
  128,
  89,
  7,
  214,
  156,
  148,
  220
]);
async function generateAesKey() {
  const key = await crypto.subtle.generateKey(
    {
      name: "AES-GCM",
      length: 256
    },
    true,
    ["encrypt", "decrypt"]
  );
  return await crypto.subtle.exportKey("raw", key).then((keyData) => new Uint8Array(keyData));
}
class AesGcm256 {
  constructor(msg, aad) {
    this.plaintext = msg;
    this.aad = aad;
  }
  generateKey() {
    return generateAesKey();
  }
  async encrypt(key) {
    const aesCryptoKey = await crypto.subtle.importKey("raw", key, "AES-GCM", false, ["encrypt"]);
    const blob = new Uint8Array(
      await crypto.subtle.encrypt(
        {
          name: "AES-GCM",
          iv,
          additionalData: this.aad
        },
        aesCryptoKey,
        this.plaintext
      )
    );
    return {
      Aes256Gcm: {
        blob,
        aad: this.aad ?? []
      }
    };
  }
  static async decrypt(key, ciphertext) {
    if (!("Aes256Gcm" in ciphertext)) {
      throw new InvalidCiphertextError(`Invalid ciphertext ${ciphertext}`);
    }
    const aesCryptoKey = await crypto.subtle.importKey("raw", key, "AES-GCM", false, ["decrypt"]);
    return new Uint8Array(
      await crypto.subtle.decrypt(
        {
          name: "AES-GCM",
          iv,
          additionalData: new Uint8Array(ciphertext.Aes256Gcm.aad ?? [])
        },
        aesCryptoKey,
        new Uint8Array(ciphertext.Aes256Gcm.blob)
      )
    );
  }
}
class Plain {
  async encrypt(_key) {
    return {
      Plain: {}
    };
  }
  generateKey() {
    return generateAesKey();
  }
}
class Hmac256Ctr {
  constructor(msg, aad) {
    this.plaintext = msg;
    this.aad = aad;
  }
  generateKey() {
    return generateAesKey();
  }
  async encrypt(key) {
    const blob = Hmac256Ctr.encryptInCtrMode(key, this.plaintext);
    const mac = Hmac256Ctr.computeMac(key, this.aad, blob);
    return {
      Hmac256Ctr: {
        blob,
        mac,
        aad: this.aad ?? []
      }
    };
  }
  static async decrypt(key, ciphertext) {
    if (!("Hmac256Ctr" in ciphertext)) {
      throw new InvalidCiphertextError(`Invalid ciphertext ${ciphertext}`);
    }
    const aad = new Uint8Array(ciphertext.Hmac256Ctr.aad ?? []);
    const blob = new Uint8Array(ciphertext.Hmac256Ctr.blob);
    const mac = Hmac256Ctr.computeMac(key, aad, blob);
    if (!equalBytes(mac, new Uint8Array(ciphertext.Hmac256Ctr.mac))) {
      throw new InvalidCiphertextError(`Invalid MAC ${mac}`);
    }
    return Hmac256Ctr.encryptInCtrMode(key, blob);
  }
  static computeMac(key, aad, ciphertext) {
    const macKey = hmac(sha3_256, key, MacKeyTag);
    const macInput = new Uint8Array([...toBytes(aad.length), ...aad, ...ciphertext]);
    const mac = hmac(sha3_256, macKey, macInput);
    return mac;
  }
  static encryptInCtrMode(key, msg) {
    const blockSize = 32;
    let result = Uint8Array.from({ length: msg.length }, () => 0);
    const encryptionKey = hmac(sha3_256, key, EncryptionKeyTag);
    for (let i = 0; i * blockSize < msg.length; i++) {
      const block = msg.slice(i * blockSize, (i + 1) * blockSize);
      let mask = hmac(sha3_256, encryptionKey, toBytes(i));
      const encryptedBlock = xorUnchecked(block, mask);
      result.set(encryptedBlock, i * blockSize);
    }
    return result;
  }
}
function toBytes(n) {
  return bcs.u64().serialize(n).toBytes();
}
const EncryptionKeyTag = new Uint8Array([1]);
const MacKeyTag = new Uint8Array([2]);
export {
  AesGcm256,
  Hmac256Ctr,
  Plain,
  iv
};
//# sourceMappingURL=dem.js.map
