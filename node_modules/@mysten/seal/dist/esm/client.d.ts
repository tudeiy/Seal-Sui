import type { SuiClient } from '@mysten/sui/client';
import { DemType, KemType } from './encrypt.js';
import type { KeyServer } from './key-server.js';
import type { SessionKey } from './session-key.js';
/**
 * Configuration options for initializing a SealClient
 * @property serverObjectIds: Array of object IDs for the key servers to use.
 * @property verifyKeyServers: Whether to verify the key servers' authenticity.
 * 	 Should be false if servers are pre-verified (e.g., getAllowlistedKeyServers).
 * 	 Defaults to true.
 * @property timeout: Timeout in milliseconds for network requests. Defaults to 10 seconds.
 */
export interface SealClientOptions {
    suiClient: SuiClient;
    serverObjectIds: string[];
    verifyKeyServers?: boolean;
    timeout?: number;
}
export declare class SealClient {
    #private;
    constructor(options: SealClientOptions);
    /**
     * Return an encrypted message under the identity.
     *
     * @param kemType - The type of KEM to use.
     * @param demType - The type of DEM to use.
     * @param threshold - The threshold for the TSS encryption.
     * @param packageId - the packageId namespace.
     * @param id - the identity to use.
     * @param data - the data to encrypt.
     * @param aad - optional additional authenticated data.
     * @returns The bcs bytes of the encrypted object containing all metadata and the 256-bit symmetric key that was used to encrypt the object.
     * 	Since the symmetric key can be used to decrypt, it should not be shared but can be used e.g. for backup.
     */
    encrypt({ kemType, demType, threshold, packageId, id, data, aad, }: {
        kemType?: KemType;
        demType?: DemType;
        threshold: number;
        packageId: string;
        id: string;
        data: Uint8Array;
        aad?: Uint8Array;
    }): Promise<{
        encryptedObject: Uint8Array;
        key: Uint8Array;
    }>;
    /**
     * Decrypt the given encrypted bytes using cached keys.
     * Calls fetchKeys in case one or more of the required keys is not cached yet.
     * The function throws an error if the client's key servers are not a subset of
     * the encrypted object's key servers (including the same weights) or if the
     * threshold cannot be met.
     *
     * @param data - The encrypted bytes to decrypt.
     * @param sessionKey - The session key to use.
     * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
     * @returns - The decrypted plaintext corresponding to ciphertext.
     */
    decrypt({ data, sessionKey, txBytes, }: {
        data: Uint8Array;
        sessionKey: SessionKey;
        txBytes: Uint8Array;
    }): Promise<Uint8Array<ArrayBufferLike>>;
    getKeyServers(): Promise<KeyServer[]>;
    /**
     * Fetch keys from the key servers and update the cache.
     *
     * It is recommended to call this function once for all ids of all encrypted obejcts if
     * there are multiple, then call decrypt for each object. This avoids calling fetchKey
     * individually for each decrypt.
     *
     * @param ids - The ids of the encrypted objects.
     * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
     * @param sessionKey - The session key to use.
     * @param threshold - The threshold for the TSS encryptions. The function returns when a threshold of key servers had returned keys for all ids.
     */
    fetchKeys({ ids, txBytes, sessionKey, threshold, }: {
        ids: string[];
        txBytes: Uint8Array;
        sessionKey: SessionKey;
        threshold: number;
    }): Promise<void>;
}
