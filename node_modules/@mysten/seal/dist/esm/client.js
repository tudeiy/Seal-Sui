var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _suiClient, _serverObjectIds, _verifyKeyServers, _keyServers, _cachedKeys, _timeout, _SealClient_instances, createEncryptionInput_fn, validateEncryptionServices_fn, loadKeyServers_fn;
import { EncryptedObject } from "./bcs.js";
import { G1Element, G2Element } from "./bls12381.js";
import { decrypt } from "./decrypt.js";
import { AesGcm256, Hmac256Ctr } from "./dem.js";
import { DemType, encrypt, KemType } from "./encrypt.js";
import {
  InconsistentKeyServersError,
  InvalidKeyServerError,
  InvalidThresholdError,
  toMajorityError
} from "./error.js";
import { BonehFranklinBLS12381Services, DST } from "./ibe.js";
import { KeyServerType, retrieveKeyServers, verifyKeyServer } from "./key-server.js";
import { fetchKeysForAllIds } from "./keys.js";
import { createFullId } from "./utils.js";
class SealClient {
  constructor(options) {
    __privateAdd(this, _SealClient_instances);
    __privateAdd(this, _suiClient);
    __privateAdd(this, _serverObjectIds);
    __privateAdd(this, _verifyKeyServers);
    __privateAdd(this, _keyServers, null);
    // A caching map for: fullId:object_id -> partial key.
    __privateAdd(this, _cachedKeys, /* @__PURE__ */ new Map());
    __privateAdd(this, _timeout);
    __privateSet(this, _suiClient, options.suiClient);
    __privateSet(this, _serverObjectIds, options.serverObjectIds);
    __privateSet(this, _verifyKeyServers, options.verifyKeyServers ?? true);
    __privateSet(this, _timeout, options.timeout ?? 1e4);
  }
  /**
   * Return an encrypted message under the identity.
   *
   * @param kemType - The type of KEM to use.
   * @param demType - The type of DEM to use.
   * @param threshold - The threshold for the TSS encryption.
   * @param packageId - the packageId namespace.
   * @param id - the identity to use.
   * @param data - the data to encrypt.
   * @param aad - optional additional authenticated data.
   * @returns The bcs bytes of the encrypted object containing all metadata and the 256-bit symmetric key that was used to encrypt the object.
   * 	Since the symmetric key can be used to decrypt, it should not be shared but can be used e.g. for backup.
   */
  async encrypt({
    kemType = KemType.BonehFranklinBLS12381DemCCA,
    demType = DemType.AesGcm256,
    threshold,
    packageId,
    id,
    data,
    aad = new Uint8Array()
  }) {
    return encrypt({
      keyServers: await this.getKeyServers(),
      kemType,
      threshold,
      packageId,
      id,
      encryptionInput: __privateMethod(this, _SealClient_instances, createEncryptionInput_fn).call(this, demType, data, aad)
    });
  }
  /**
   * Decrypt the given encrypted bytes using cached keys.
   * Calls fetchKeys in case one or more of the required keys is not cached yet.
   * The function throws an error if the client's key servers are not a subset of
   * the encrypted object's key servers (including the same weights) or if the
   * threshold cannot be met.
   *
   * @param data - The encrypted bytes to decrypt.
   * @param sessionKey - The session key to use.
   * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
   * @returns - The decrypted plaintext corresponding to ciphertext.
   */
  async decrypt({
    data,
    sessionKey,
    txBytes
  }) {
    const encryptedObject = EncryptedObject.parse(data);
    __privateMethod(this, _SealClient_instances, validateEncryptionServices_fn).call(this, encryptedObject.services.map((s) => s[0]), encryptedObject.threshold);
    await this.fetchKeys({
      ids: [encryptedObject.id],
      txBytes,
      sessionKey,
      threshold: encryptedObject.threshold
    });
    return decrypt({ encryptedObject, keys: __privateGet(this, _cachedKeys) });
  }
  async getKeyServers() {
    if (!__privateGet(this, _keyServers)) {
      __privateSet(this, _keyServers, __privateMethod(this, _SealClient_instances, loadKeyServers_fn).call(this).catch((error) => {
        __privateSet(this, _keyServers, null);
        throw error;
      }));
    }
    return __privateGet(this, _keyServers);
  }
  /**
   * Fetch keys from the key servers and update the cache.
   *
   * It is recommended to call this function once for all ids of all encrypted obejcts if
   * there are multiple, then call decrypt for each object. This avoids calling fetchKey
   * individually for each decrypt.
   *
   * @param ids - The ids of the encrypted objects.
   * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
   * @param sessionKey - The session key to use.
   * @param threshold - The threshold for the TSS encryptions. The function returns when a threshold of key servers had returned keys for all ids.
   */
  async fetchKeys({
    ids,
    txBytes,
    sessionKey,
    threshold
  }) {
    const keyServers = await this.getKeyServers();
    if (threshold > keyServers.length || threshold < 1 || keyServers.length < 1) {
      throw new InvalidThresholdError(
        `Invalid threshold ${threshold} for ${keyServers.length} servers`
      );
    }
    let completedServerCount = 0;
    const remainingKeyServers = /* @__PURE__ */ new Set();
    const fullIds = ids.map((id) => createFullId(DST, sessionKey.getPackageId(), id));
    for (const server of keyServers) {
      let hasAllKeys = true;
      for (const fullId of fullIds) {
        if (!__privateGet(this, _cachedKeys).has(`${fullId}:${server.objectId}`)) {
          hasAllKeys = false;
          remainingKeyServers.add(server);
          break;
        }
      }
      if (hasAllKeys) {
        completedServerCount++;
      }
    }
    if (completedServerCount >= threshold) {
      return;
    }
    for (const server of remainingKeyServers) {
      if (server.keyType !== KeyServerType.BonehFranklinBLS12381) {
        throw new InvalidKeyServerError(
          `Server ${server.objectId} has invalid key type: ${server.keyType}`
        );
      }
    }
    const cert = await sessionKey.getCertificate();
    const signedRequest = await sessionKey.createRequestParams(txBytes);
    const controller = new AbortController();
    const errors = [];
    const keyFetches = [...remainingKeyServers].map(async (server) => {
      try {
        const allKeys = await fetchKeysForAllIds(
          server.url,
          signedRequest.requestSignature,
          txBytes,
          signedRequest.decryptionKey,
          cert,
          __privateGet(this, _timeout),
          controller.signal
        );
        let receivedIds = /* @__PURE__ */ new Set();
        for (const { fullId, key } of allKeys) {
          const keyElement = G1Element.fromBytes(key);
          if (!BonehFranklinBLS12381Services.verifyUserSecretKey(
            keyElement,
            fullId,
            G2Element.fromBytes(server.pk)
          )) {
            console.warn("Received invalid key from key server " + server.objectId);
            continue;
          }
          __privateGet(this, _cachedKeys).set(`${fullId}:${server.objectId}`, keyElement);
          receivedIds.add(fullId);
        }
        const expectedIds = new Set(fullIds);
        const hasAllKeys = receivedIds.size === expectedIds.size && [...receivedIds].every((id) => expectedIds.has(id));
        if (hasAllKeys) {
          completedServerCount++;
          if (completedServerCount >= threshold) {
            controller.abort();
          }
        }
      } catch (error) {
        if (!controller.signal.aborted) {
          errors.push(error);
        }
        if (remainingKeyServers.size - errors.length < threshold - completedServerCount) {
          controller.abort(error);
        }
      }
    });
    await Promise.allSettled(keyFetches);
    if (completedServerCount < threshold) {
      throw toMajorityError(errors);
    }
  }
}
_suiClient = new WeakMap();
_serverObjectIds = new WeakMap();
_verifyKeyServers = new WeakMap();
_keyServers = new WeakMap();
_cachedKeys = new WeakMap();
_timeout = new WeakMap();
_SealClient_instances = new WeakSet();
createEncryptionInput_fn = function(type, data, aad) {
  switch (type) {
    case DemType.AesGcm256:
      return new AesGcm256(data, aad);
    case DemType.Hmac256Ctr:
      return new Hmac256Ctr(data, aad);
  }
};
validateEncryptionServices_fn = function(services, threshold) {
  const serverObjectIdsMap = /* @__PURE__ */ new Map();
  for (const objectId of __privateGet(this, _serverObjectIds)) {
    serverObjectIdsMap.set(objectId, (serverObjectIdsMap.get(objectId) ?? 0) + 1);
  }
  const servicesMap = /* @__PURE__ */ new Map();
  for (const service of services) {
    servicesMap.set(service, (servicesMap.get(service) ?? 0) + 1);
  }
  for (const [objectId, count] of serverObjectIdsMap) {
    if (servicesMap.get(objectId) !== count) {
      throw new InconsistentKeyServersError(
        `Client's key servers must be a subset of the encrypted object's key servers`
      );
    }
  }
  if (threshold > __privateGet(this, _serverObjectIds).length) {
    throw new InvalidThresholdError(
      `Invalid threshold ${threshold} for ${__privateGet(this, _serverObjectIds).length} servers`
    );
  }
};
loadKeyServers_fn = async function() {
  const keyServers = await retrieveKeyServers({
    objectIds: __privateGet(this, _serverObjectIds),
    client: __privateGet(this, _suiClient)
  });
  if (keyServers.length === 0) {
    throw new InvalidKeyServerError("No key servers found");
  }
  if (__privateGet(this, _verifyKeyServers)) {
    await Promise.all(
      keyServers.map(async (server) => {
        if (!await verifyKeyServer(server, __privateGet(this, _timeout))) {
          throw new InvalidKeyServerError(`Key server ${server.objectId} is not valid`);
        }
      })
    );
  }
  return keyServers;
};
export {
  SealClient
};
//# sourceMappingURL=client.js.map
