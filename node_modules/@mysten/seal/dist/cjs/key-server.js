"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var key_server_exports = {};
__export(key_server_exports, {
  KeyServerType: () => KeyServerType,
  getAllowlistedKeyServers: () => getAllowlistedKeyServers,
  retrieveKeyServers: () => retrieveKeyServers,
  verifyKeyServer: () => verifyKeyServer
});
module.exports = __toCommonJS(key_server_exports);
var import_bcs = require("@mysten/bcs");
var import_bls12_381 = require("@noble/curves/bls12-381");
var import_bcs2 = require("./bcs.js");
var import_error = require("./error.js");
var import_ibe = require("./ibe.js");
var import_version = require("./version.js");
var KeyServerType = /* @__PURE__ */ ((KeyServerType2) => {
  KeyServerType2[KeyServerType2["BonehFranklinBLS12381"] = 0] = "BonehFranklinBLS12381";
  return KeyServerType2;
})(KeyServerType || {});
function getAllowlistedKeyServers(network) {
  if (network === "testnet") {
    return [
      "0xb35a7228d8cf224ad1e828c0217c95a5153bafc2906d6f9c178197dce26fbcf8",
      "0x2d6cde8a9d9a65bde3b0a346566945a63b4bfb70e9a06c41bdb70807e2502b06"
    ];
  } else {
    throw new import_error.UnsupportedNetworkError(`Unsupported network ${network}`);
  }
}
async function retrieveKeyServers({
  objectIds,
  client
}) {
  return await Promise.all(
    objectIds.map(async (objectId) => {
      const res = await client.getObject({
        id: objectId,
        options: {
          showBcs: true
        }
      });
      if (!res || res.error || !res.data) {
        throw new import_error.InvalidGetObjectError(`KeyServer ${objectId} not found; ${res.error}`);
      }
      if (!res.data.bcs || !("bcsBytes" in res.data.bcs)) {
        throw new import_error.InvalidGetObjectError(
          `Invalid KeyServer query: ${objectId}, expected object, got package`
        );
      }
      let ks = import_bcs2.KeyServerMove.parse((0, import_bcs.fromBase64)(res.data.bcs.bcsBytes));
      if (ks.keyType !== 0) {
        throw new import_error.UnsupportedFeatureError(`Unsupported key type ${ks.keyType}`);
      }
      return {
        objectId,
        name: ks.name,
        url: ks.url,
        keyType: 0 /* BonehFranklinBLS12381 */,
        pk: new Uint8Array(ks.pk)
      };
    })
  );
}
async function verifyKeyServer(server, timeout) {
  const requestId = crypto.randomUUID();
  const response = await fetch(server.url + "/v1/service", {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Request-Id": requestId,
      "Client-Sdk-Type": "typescript",
      "Client-Sdk-Version": import_version.PACKAGE_VERSION
    },
    signal: AbortSignal.timeout(timeout)
  });
  await import_error.SealAPIError.assertResponse(response, requestId);
  const serviceResponse = await response.json();
  if (serviceResponse.service_id !== server.objectId) {
    return false;
  }
  const fullMsg = new Uint8Array([...import_ibe.DST_POP, ...server.pk, ...(0, import_bcs.fromHex)(server.objectId)]);
  return import_bls12_381.bls12_381.verifyShortSignature((0, import_bcs.fromBase64)(serviceResponse.pop), fullMsg, server.pk);
}
//# sourceMappingURL=key-server.js.map
