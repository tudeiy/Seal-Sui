"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var client_exports = {};
__export(client_exports, {
  SealClient: () => SealClient
});
module.exports = __toCommonJS(client_exports);
var import_bcs = require("./bcs.js");
var import_bls12381 = require("./bls12381.js");
var import_decrypt = require("./decrypt.js");
var import_dem = require("./dem.js");
var import_encrypt = require("./encrypt.js");
var import_error = require("./error.js");
var import_ibe = require("./ibe.js");
var import_key_server = require("./key-server.js");
var import_keys = require("./keys.js");
var import_utils = require("./utils.js");
var _suiClient, _serverObjectIds, _verifyKeyServers, _keyServers, _cachedKeys, _timeout, _SealClient_instances, createEncryptionInput_fn, validateEncryptionServices_fn, loadKeyServers_fn;
class SealClient {
  constructor(options) {
    __privateAdd(this, _SealClient_instances);
    __privateAdd(this, _suiClient);
    __privateAdd(this, _serverObjectIds);
    __privateAdd(this, _verifyKeyServers);
    __privateAdd(this, _keyServers, null);
    // A caching map for: fullId:object_id -> partial key.
    __privateAdd(this, _cachedKeys, /* @__PURE__ */ new Map());
    __privateAdd(this, _timeout);
    __privateSet(this, _suiClient, options.suiClient);
    __privateSet(this, _serverObjectIds, options.serverObjectIds);
    __privateSet(this, _verifyKeyServers, options.verifyKeyServers ?? true);
    __privateSet(this, _timeout, options.timeout ?? 1e4);
  }
  /**
   * Return an encrypted message under the identity.
   *
   * @param kemType - The type of KEM to use.
   * @param demType - The type of DEM to use.
   * @param threshold - The threshold for the TSS encryption.
   * @param packageId - the packageId namespace.
   * @param id - the identity to use.
   * @param data - the data to encrypt.
   * @param aad - optional additional authenticated data.
   * @returns The bcs bytes of the encrypted object containing all metadata and the 256-bit symmetric key that was used to encrypt the object.
   * 	Since the symmetric key can be used to decrypt, it should not be shared but can be used e.g. for backup.
   */
  async encrypt({
    kemType = import_encrypt.KemType.BonehFranklinBLS12381DemCCA,
    demType = import_encrypt.DemType.AesGcm256,
    threshold,
    packageId,
    id,
    data,
    aad = new Uint8Array()
  }) {
    return (0, import_encrypt.encrypt)({
      keyServers: await this.getKeyServers(),
      kemType,
      threshold,
      packageId,
      id,
      encryptionInput: __privateMethod(this, _SealClient_instances, createEncryptionInput_fn).call(this, demType, data, aad)
    });
  }
  /**
   * Decrypt the given encrypted bytes using cached keys.
   * Calls fetchKeys in case one or more of the required keys is not cached yet.
   * The function throws an error if the client's key servers are not a subset of
   * the encrypted object's key servers (including the same weights) or if the
   * threshold cannot be met.
   *
   * @param data - The encrypted bytes to decrypt.
   * @param sessionKey - The session key to use.
   * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
   * @returns - The decrypted plaintext corresponding to ciphertext.
   */
  async decrypt({
    data,
    sessionKey,
    txBytes
  }) {
    const encryptedObject = import_bcs.EncryptedObject.parse(data);
    __privateMethod(this, _SealClient_instances, validateEncryptionServices_fn).call(this, encryptedObject.services.map((s) => s[0]), encryptedObject.threshold);
    await this.fetchKeys({
      ids: [encryptedObject.id],
      txBytes,
      sessionKey,
      threshold: encryptedObject.threshold
    });
    return (0, import_decrypt.decrypt)({ encryptedObject, keys: __privateGet(this, _cachedKeys) });
  }
  async getKeyServers() {
    if (!__privateGet(this, _keyServers)) {
      __privateSet(this, _keyServers, __privateMethod(this, _SealClient_instances, loadKeyServers_fn).call(this).catch((error) => {
        __privateSet(this, _keyServers, null);
        throw error;
      }));
    }
    return __privateGet(this, _keyServers);
  }
  /**
   * Fetch keys from the key servers and update the cache.
   *
   * It is recommended to call this function once for all ids of all encrypted obejcts if
   * there are multiple, then call decrypt for each object. This avoids calling fetchKey
   * individually for each decrypt.
   *
   * @param ids - The ids of the encrypted objects.
   * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
   * @param sessionKey - The session key to use.
   * @param threshold - The threshold for the TSS encryptions. The function returns when a threshold of key servers had returned keys for all ids.
   */
  async fetchKeys({
    ids,
    txBytes,
    sessionKey,
    threshold
  }) {
    const keyServers = await this.getKeyServers();
    if (threshold > keyServers.length || threshold < 1 || keyServers.length < 1) {
      throw new import_error.InvalidThresholdError(
        `Invalid threshold ${threshold} for ${keyServers.length} servers`
      );
    }
    let completedServerCount = 0;
    const remainingKeyServers = /* @__PURE__ */ new Set();
    const fullIds = ids.map((id) => (0, import_utils.createFullId)(import_ibe.DST, sessionKey.getPackageId(), id));
    for (const server of keyServers) {
      let hasAllKeys = true;
      for (const fullId of fullIds) {
        if (!__privateGet(this, _cachedKeys).has(`${fullId}:${server.objectId}`)) {
          hasAllKeys = false;
          remainingKeyServers.add(server);
          break;
        }
      }
      if (hasAllKeys) {
        completedServerCount++;
      }
    }
    if (completedServerCount >= threshold) {
      return;
    }
    for (const server of remainingKeyServers) {
      if (server.keyType !== import_key_server.KeyServerType.BonehFranklinBLS12381) {
        throw new import_error.InvalidKeyServerError(
          `Server ${server.objectId} has invalid key type: ${server.keyType}`
        );
      }
    }
    const cert = await sessionKey.getCertificate();
    const signedRequest = await sessionKey.createRequestParams(txBytes);
    const controller = new AbortController();
    const errors = [];
    const keyFetches = [...remainingKeyServers].map(async (server) => {
      try {
        const allKeys = await (0, import_keys.fetchKeysForAllIds)(
          server.url,
          signedRequest.requestSignature,
          txBytes,
          signedRequest.decryptionKey,
          cert,
          __privateGet(this, _timeout),
          controller.signal
        );
        let receivedIds = /* @__PURE__ */ new Set();
        for (const { fullId, key } of allKeys) {
          const keyElement = import_bls12381.G1Element.fromBytes(key);
          if (!import_ibe.BonehFranklinBLS12381Services.verifyUserSecretKey(
            keyElement,
            fullId,
            import_bls12381.G2Element.fromBytes(server.pk)
          )) {
            console.warn("Received invalid key from key server " + server.objectId);
            continue;
          }
          __privateGet(this, _cachedKeys).set(`${fullId}:${server.objectId}`, keyElement);
          receivedIds.add(fullId);
        }
        const expectedIds = new Set(fullIds);
        const hasAllKeys = receivedIds.size === expectedIds.size && [...receivedIds].every((id) => expectedIds.has(id));
        if (hasAllKeys) {
          completedServerCount++;
          if (completedServerCount >= threshold) {
            controller.abort();
          }
        }
      } catch (error) {
        if (!controller.signal.aborted) {
          errors.push(error);
        }
        if (remainingKeyServers.size - errors.length < threshold - completedServerCount) {
          controller.abort(error);
        }
      }
    });
    await Promise.allSettled(keyFetches);
    if (completedServerCount < threshold) {
      throw (0, import_error.toMajorityError)(errors);
    }
  }
}
_suiClient = new WeakMap();
_serverObjectIds = new WeakMap();
_verifyKeyServers = new WeakMap();
_keyServers = new WeakMap();
_cachedKeys = new WeakMap();
_timeout = new WeakMap();
_SealClient_instances = new WeakSet();
createEncryptionInput_fn = function(type, data, aad) {
  switch (type) {
    case import_encrypt.DemType.AesGcm256:
      return new import_dem.AesGcm256(data, aad);
    case import_encrypt.DemType.Hmac256Ctr:
      return new import_dem.Hmac256Ctr(data, aad);
  }
};
validateEncryptionServices_fn = function(services, threshold) {
  const serverObjectIdsMap = /* @__PURE__ */ new Map();
  for (const objectId of __privateGet(this, _serverObjectIds)) {
    serverObjectIdsMap.set(objectId, (serverObjectIdsMap.get(objectId) ?? 0) + 1);
  }
  const servicesMap = /* @__PURE__ */ new Map();
  for (const service of services) {
    servicesMap.set(service, (servicesMap.get(service) ?? 0) + 1);
  }
  for (const [objectId, count] of serverObjectIdsMap) {
    if (servicesMap.get(objectId) !== count) {
      throw new import_error.InconsistentKeyServersError(
        `Client's key servers must be a subset of the encrypted object's key servers`
      );
    }
  }
  if (threshold > __privateGet(this, _serverObjectIds).length) {
    throw new import_error.InvalidThresholdError(
      `Invalid threshold ${threshold} for ${__privateGet(this, _serverObjectIds).length} servers`
    );
  }
};
loadKeyServers_fn = async function() {
  const keyServers = await (0, import_key_server.retrieveKeyServers)({
    objectIds: __privateGet(this, _serverObjectIds),
    client: __privateGet(this, _suiClient)
  });
  if (keyServers.length === 0) {
    throw new import_error.InvalidKeyServerError("No key servers found");
  }
  if (__privateGet(this, _verifyKeyServers)) {
    await Promise.all(
      keyServers.map(async (server) => {
        if (!await (0, import_key_server.verifyKeyServer)(server, __privateGet(this, _timeout))) {
          throw new import_error.InvalidKeyServerError(`Key server ${server.objectId} is not valid`);
        }
      })
    );
  }
  return keyServers;
};
//# sourceMappingURL=client.js.map
