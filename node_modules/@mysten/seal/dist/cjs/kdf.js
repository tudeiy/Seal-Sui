"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var kdf_exports = {};
__export(kdf_exports, {
  KeyPurpose: () => KeyPurpose,
  deriveKey: () => deriveKey,
  kdf: () => kdf
});
module.exports = __toCommonJS(kdf_exports);
var import_bcs = require("@mysten/bcs");
var import_hkdf = require("@noble/hashes/hkdf");
var import_hmac = require("@noble/hashes/hmac");
var import_sha3 = require("@noble/hashes/sha3");
var import_bls12381 = require("./bls12381.js");
function kdf(element, nonce, id, objectId, index) {
  const GT_ELEMENT_BYTE_LENGTH = 576;
  const PERMUTATION = [0, 2, 4, 1, 3, 5];
  const COEFFICIENT_SIZE = GT_ELEMENT_BYTE_LENGTH / PERMUTATION.length;
  const bytes = element.toBytes();
  let permutedBytes = new Uint8Array(GT_ELEMENT_BYTE_LENGTH);
  PERMUTATION.forEach((pi, i) => {
    permutedBytes.set(
      bytes.slice(i * COEFFICIENT_SIZE, (i + 1) * COEFFICIENT_SIZE),
      pi * COEFFICIENT_SIZE
    );
  });
  const inputBytes = new Uint8Array([
    ...permutedBytes,
    ...nonce.toBytes(),
    ...import_bls12381.G1Element.hashToCurve(id).toBytes()
  ]);
  const info = new Uint8Array([...(0, import_bcs.fromHex)(objectId), index]);
  return (0, import_hkdf.hkdf)(import_sha3.sha3_256, inputBytes, "", info, 32);
}
var KeyPurpose = /* @__PURE__ */ ((KeyPurpose2) => {
  KeyPurpose2[KeyPurpose2["EncryptedRandomness"] = 0] = "EncryptedRandomness";
  KeyPurpose2[KeyPurpose2["DEM"] = 1] = "DEM";
  return KeyPurpose2;
})(KeyPurpose || {});
function deriveKey(purpose, baseKey) {
  switch (purpose) {
    case 0 /* EncryptedRandomness */:
      return (0, import_hmac.hmac)(import_sha3.sha3_256, baseKey, new Uint8Array([0]));
    case 1 /* DEM */:
      return (0, import_hmac.hmac)(import_sha3.sha3_256, baseKey, new Uint8Array([1]));
  }
}
//# sourceMappingURL=kdf.js.map
