import type { Ciphertext } from './bcs.js';
export declare const iv: Uint8Array<ArrayBuffer>;
export interface EncryptionInput {
    encrypt(key: Uint8Array): Promise<typeof Ciphertext.$inferInput>;
    generateKey(): Promise<Uint8Array>;
}
export declare class AesGcm256 implements EncryptionInput {
    readonly plaintext: Uint8Array;
    readonly aad: Uint8Array;
    constructor(msg: Uint8Array, aad: Uint8Array);
    generateKey(): Promise<Uint8Array>;
    encrypt(key: Uint8Array): Promise<typeof Ciphertext.$inferInput>;
    static decrypt(key: Uint8Array, ciphertext: typeof Ciphertext.$inferInput): Promise<Uint8Array>;
}
export declare class Plain implements EncryptionInput {
    encrypt(_key: Uint8Array): Promise<typeof Ciphertext.$inferInput>;
    generateKey(): Promise<Uint8Array>;
}
/**
 * Authenticated encryption using CTR mode with HMAC-SHA3-256 as a PRF.
 * 1. Derive an encryption key, <i>k<sub>1</sub> = <b>hmac</b>(key, 1)</i>.
 * 2. Chunk the message into blocks of 32 bytes, <i>m = m<sub>1</sub> || ... || m<sub>n</sub></i>.
 * 3. Let the ciphertext be defined by <i>c = c<sub>1</sub> || ... || c<sub>n</sub></i> where <i>c<sub>i</sub> = m<sub>i</sub> âŠ• <b>hmac</b>(k<sub>1</sub>, i)</i>.
 * 4. Compute a MAC over the AAD and the ciphertext, <i>mac = <b>hmac</b>(k<sub>2</sub>, aad || c) where k<sub>2</sub> = <b>hmac</b>(key, 2)</i>.
 * 5. Return <i>mac || c</i>.
 */
export declare class Hmac256Ctr implements EncryptionInput {
    readonly plaintext: Uint8Array;
    readonly aad: Uint8Array;
    constructor(msg: Uint8Array, aad: Uint8Array);
    generateKey(): Promise<Uint8Array>;
    encrypt(key: Uint8Array): Promise<typeof Ciphertext.$inferInput>;
    static decrypt(key: Uint8Array, ciphertext: typeof Ciphertext.$inferInput): Promise<Uint8Array>;
    private static computeMac;
    private static encryptInCtrMode;
}
